\clearpage

\def\PRName#1{\textsc{Pre-#1}}
\newcommand\ra{\rightarrow}
\newcommand\vp{\varphi}
\newcommand\tr{\triangleright}
\newcommand{\proc}{\*{Proc}}
\newcommand{\bufst}{\*{BufState}}
\newcommand{\sups}{\*{Sups}}
\newcommand{\clis}{\*{Clis}}
\newcommand{\xducer}{\*{Xducer}}


\chapter{Implementation}

In this chapter, we will first talk about the high-level interpreter of a minimal SNESL language but with extension of user-defined functions to give the reader a more concrete feeling about SNESL. 
Then we introduce the streaming low-level language, SVCODE, with respect to its grammar, semantics and primitive operations.
Translation from the high-level language to the low-level one will be explained to show their connections.
Finally, two interpreters of SVCODE will be described and compared with emphsis on the latter one to demonstrate the streaming machnism.



\section{High-level interpreter}

In this thesis, the high-level language we have experimented with is a subset of SNESL introduced in the last chapter but without vectors. We will call this language SNESL1.
As our first goal is to extend SNESL with user-defined (recursive) functions,
it is safe to do experiments only with SNESL1 because removing vectors from SNESL should not affect the complexity of the problem too much; we believe that if the solution works with streams, the general type in SNESL, it should be trivial to make it support vectors. 


Tuples are also simplified as pairs in SNESL1. 
Then the type system for SNESL1 is as follows.
\begin{align*} 
& \vp ::= \bool \ | \ \int \ | \ (\vp_1,\vp_2) \\
& \tau ::= \vp \ | \ (\tau_1,\tau_2) \ | \ \tseq{\tau}  
\end{align*}

The values in SNESL1:
\begin{align*}
& a ::=  \T \ | \ \F \ | \ n  \ | \ (a_1,a_2) \\
& v ::=  a \ | \ (v_1,v_2) \ | \ \{v_1,...,v_k\} 
\end{align*}

The grammar of the interpreter for SNESL1 is given in \ref{fig-mysnesl}. 
 

\begin{figure}[H]\large
	\begin{alignat*}{2}
	& t &&::= e \ | \ d  \tag{top-level statement} \\
	\\
	& e &&::=  a \     \tag{constant} \\
	&   && \quad | \ x  \tag{variable} \\
	&   && \quad | \ (e_1,e_2) \tag{pair}\\
	&   && \quad | \ \{e_1,...,e_k \}	\tag{???primitive sequence} \\
	&   && \quad | \ \{ \}\tau			\tag{???empty sequence of type $\tau$} \\
	&   && \quad | \ \Let{x}{e_1}{e_2} \tag{let-binding}\\
	&   && \quad | \ \hcall{\Tupk{x}}  \tag{built-in function call} \\
	&   && \quad | \ \Comp{e_1}{x}{y}{\usevars} \tag{general comprehension} \\
	&   && \quad | \ \RComp{e_1}{x}{\usevars} \tag {restricted comprehension} \\
	&   && \quad | \ f(x_1,...,x_k)  \tag {user-defined function call} \\
	\\
	& d &&::= function \  f(x_1: \tau_1, ..., x_k: \tau_k): \tau = e  \tag{user-defined function}
	\end{alignat*}
	\caption{Grammar of high-level interpreter \label{fig-mysnesl}}
\end{figure}

The high-level interpreter we have implemented supports interpreting both SNESL1 expressions and function definitions. 
%The reader may find that, compared to the grammar in Figure~\ref{fig-snesl-exps}, we simplified tuples of arbitrary number of components to paris of only two components; also, primitive sequence and empty sequence are added. These small changes just make the language we experiment with as simple as possible to analyze, and also convenient for programming tests.
Since type inference is not incorporated in the interpreter, the types of  parameters and return values need to be provided when the user defines a function.

The typing rules of SNES1 is given in Figure~\ref{fig-snesl1-typing}. The type environment $\Gam$ is a mapping from variables to types: $$\Gamma = [x_1 \|-> \tau_1, ..., x_i \|-> {\tau_i} ]$$.
(may add explaination of how to type user-defined functions)
\fig{
	\Jug{\Type{\Gam}{e}{\tau}}
	
	\PT{
		\RiLa{(\TypeV{a}{\vp})}
		\Axiom{\Type{\Gam}{a}{\vp}}
	}
	\PT{
		\AxiomC{}
		\RiLa{(\Gam(x) = \tau)}
		\UC{\Type{\Gam}{x}{\tau}}
	}
	\PT{
		\AC{\Type{\Gam}{e_1}{\tau_1}}
		\AC{\Type{\Gam}{e_2}{\tau_2}}
		\BC{\Type{\Gam}{(e_1,e_2)}{(\tau_1,\tau_2)}}
	}\\[3ex]
	
	\PT{
		\AC{\Type{\Gam}{e_1}{\tau}}
		\AC{...}
		\AC{\Type{\Gam}{e_k}{\tau}}
		\TC{\Type{\Gam}{\{e_1,...,e_k\}}{\{\tau\}}}
	}
	\PT{\Axiom{\Type{\Gam}{\{\}\tau}{\{\tau}\}}}
	\\[3ex]
	
	
	\PT{
		\AC{\Type{\Gam}{e_1}{\tau_1}}
		\AC{\Type{\Gam[x \|-> \tau_1]}{e_2}{\tau}}
		\BC{\Type{\Gam}{\Let{x}{e_1}{e_2}}{\tau}}
	}	
	\PT{
		\AC{\Typef {\hcall} {\replc{k}{\tau}} {\tau}}
		\RiLa{((\Gam(x_i)= \tau_i)^k_{i=1})}
		\UC{\Type{\Gam}{\hcall{\Tupk{x}}}{\tau}}
	}\\[3ex]
	
	\PT{
		\AC{\Type{[x \|-> {\tau_1}, \j{x_i \|-> \vp_i}]}{e_1}{\tau}}
		\RiLa{(\Gam(y)=\tseq{\tau_1}, \j{\Gam(x_i) = \vp_i})}
		\UC{\Type{\Gam}{\Comp{e_1}{x}{y}{\usevars}}{\tseq{\tau}}}
	}\\[3ex]
	
	\PT{
		\AC{\Type{[\j{x_i \|-> \tau_i}]}{e_1}{\tau}}
		\RiLa{(\Gam(x)= \bool, \j{\Gam(x_i) = \tau_i})}
		\UC{\Type{\Gam}{\RComp{e_1}{x}{\usevars}}{\tseq{\tau}}}
	}\\[3ex]

	\PT{
		\AC{\Typef{f}{\tau_1,...,\tau_i}{\tau}}
		\LeLa{???}
		\RiLa{(\k{\Gam(x_i) = \tau_i})}
		\UC{\Type{\Gam}{f(x_1,...,x_k)}{\tau}}
	}
%	
%	\item \Jug{\Typef {\hcall} {\replc{k}{\tau}} {\tau}}
%	
%	\PT{\Axiom{\Typef{\constn{n}}{}{\int}}}
%	\PT{\Axiom{\Typef{\iotan}{\int} {\tseq{\int}}}}
%	\PT{\Axiom{\Typef{\plusn}{\int,\int} {\int}}}
	
}{Typing rules of SNESL1 \label{fig-snesl1-typing}}



Value typing rules: \\

\Jug{\TypeV{a}{\vp}}

\PT{\Axiom{\TypeV{n}{\int}}}
\PT{\Axiom{\TypeV{\T}{\bool}}}
\PT{\Axiom{\TypeV{\F}{\bool}}}
\PT{
	\AC{\TypeV{a_1}{\vp_1}}
	\AC{\TypeV{a_2}{\vp_2}}
	\BC{\TypeV{(a_1,a_2)} {(\vp_1,\vp_2)}}
}\\[3ex]


\Jug{\TypeV{v}{\tau}}

\PT{\Axiom{\TypeV{a}{\vp}}}
\PT{
	\AC{\TypeV{v_1}{\tau_1}}
	\AC{\TypeV{v_2}{\tau_2}}
	\BC{\TypeV{(v_1,v_2)}{(\tau_1,\tau_2)}}
}
\PT{
	\AC{\TypeV{v_1}{\tau}}
	\AC{...}
	\AC{\TypeV{v_k}{\tau}}
	\TC{\TypeV{\Seqk{v}}{\{\tau\}}}
}\\[3ex]



Semantics of SNESL1 with cost (TODO: add cost): \\
%TODO: add cost
Evaluation environment $ \rho = [x_1 \|-> v_1,...,x_i \|-> v_i]$ \\

 \Jug{\Eval{\rho}{e}{v}}
	 \PT{
	 	\Axiom{\Eval{\rho}{a}{a}}
	 }
	\PT{
		\AxiomC{}
		\RiLa{(\rho(x)=v)}
		\UC{\Eval{\rho}{x}{v}}
	}
	\PT{
		\AC{\Eval{\rho}{e_1}{v_1}}
		\AC{\Eval{\rho}{e_2}{v_2}}
		\BC{\Eval{\rho}{(e_1,e_2)}{(v_1,v_2)}}	
	}\\[3ex]
	\PT{
		\AC{\Eval{\rho}{e_1}{v_1}}
		\AC{...}
		\AC{\Eval{\rho}{e_k}{v_k}}
		\TC{\Eval{\rho}{\{e_1,...,e_k\}}{\{v_1,...,v_k\}}}	
	}
	\PT{
		\Axiom{\Eval{\rho}{\{\}\tau}{\{\}}}
	}\\[3ex]

	\PT{
		\AC{\Eval{\rho}{e_1}{v_1}}
		\AC{\Eval{\rho[x \|-> v_1]}{e_2}{v}}
		\BC{\Eval{\rho}{\Let{e_1}{x}{e_2}}{v}}	
	}
	\PT{
		\AC{\EvalF\hcall{\replc{k}{v}}{v}}
		\RiLa{((\rho(x_i)=v_i)^k_{i=1})}
		\UC{\Eval{\rho}{\hcall{\Tupk{x}}}{v}}
	}\\[3ex]
	
	\PT{
		\AC{(\Eval{[x \|-> {v_i}, \j{x_i \|-> a_i}]}{e_1}{v_i'})^k_{i=1}}
		\RiLa{(\rho(y)=\Seqk{v}, \j{\rho(x_i) = a_i})}
		\UC{\Eval{\rho}{\Comp{e_1}{x}{y}{\usevars}}{\Seqk{v'}}}
	}\\[3ex]
	
	\PT{
		\AC{}
		\RiLa{(\rho(x)= \F)}
		\UC{\Eval{\rho}{\RComp{e_1}{x}{\usevars}}{\{\}}}
	}\\[3ex]
	\PT{
		\AC{\Eval{\rho}{e_1}{v_1}}
		\RiLa{(\rho(x)= \T)}
		\UC{\Eval{\rho}{\RComp{e_1}{x}{\usevars}}{\{v_1\}}}
	}\\[3ex]
	\PT{
		\AC{\Eval{\rho}{f(x_1,...,x_k)}{???}}
	}\\[3ex]


The built-in functions are also a subset of SNESL built-in functions shown in Figure~\ref{fig-snesl-func} but  the vector-related ones are removed, as shown in Figure~\ref{fig-mysnesl-func}. 

\begin{figure}[h]
	\begin{alignat*}{2} 
	&\hcall && ::= \oplus \ | \  \ \*{append} \ | \ \*{concat}  \ | \ \*{iota}  \ | \ \*{part}  \ | \ \*{scan}_\otimes \ | \ \*{reduce}_{\otimes} \ | \ \*{the}  \ | \ \*{empty} \\
	& \oplus  \ && :: = + \ | \ - \ | \ \times \ |  \  \div \ | \ \% \ | \le \ | \ ... \tag{consts operations} \\
	& \otimes \ && :: = + \ | \ \times  \ | \ ...  \tag{associative binary operations}
	\end{alignat*}
	\caption{Primitive functions in SNESL1 \label{fig-mysnesl-func}}
\end{figure}

The consts operations of $\oplus$ should be self-explained from their conventional names. 
The types, short descriptions and examples of the other streamable operations are given below.

\begin{itemize}

	\item $\*{append : (\{\tau\} \times \{\tau\}) \ra \{\tau\}}$ , 
	appends one sequence to the end of another; syntactic-sugared as the infix symbol {\++}.

	\begin{figure}[H]
	\begin{example}
	\end{example}
	\begin{lstlisting}[style = nesl-style]
	> {3,1} ++ {4}
	{3,1,4} :: {int}
	
	> {{3,1},{4}} ++ {{}int} ++ {{1,5}}
	{{3,1},{4},{},{1,5}} :: {{int}}
	\end{lstlisting}
	\end{figure}


	\item $\*{concat: \{\{\tau\}\} \rightarrow \{\tau\} }$, concatenates the elements of type sequence into one sequence. 
	\begin{figure}[H]
	\begin{example}
	\end{example}
	\begin{lstlisting}[style = nesl-style]
	> concat({{3,1},{4}})
	{3,1,4} :: {int}
	
	> concat({{{3,1}, {4}}, {{1}}})
	{{3,1},{4},{1}} :: {{int}}
	\end{lstlisting}
	\end{figure}

	\item $\*{iota: \int \ra \{\int\}}$, generates a sequence of integers starting from 0 to the given argument integer minus 1; syntactic-sugared as the symbol \&. 
	\begin{figure}[H]
	\begin{example}
	\end{example}
	\begin{lstlisting}[style = nesl-style]
	> &10
	{0,1,2,3,4,5,6,7,8,9} :: {int}
	
	> &0
	{} :: {int}
	\end{lstlisting}
	\end{figure}
	
	\item $\*{part: (\{\tau\} \times \{\bool\}) \ra  \{\{\tau\}\}}$,  partitions a sequence into subsequences segmented by the second descriptor argument. 
	\begin{figure}[H]
	\begin{example}
	\end{example}
	\begin{lstlisting}[style = nesl-style]
	> part({3,1,4,1,5,9}, {F,F,T,F,T,T,F,F,F,T})
	{{3,1},{4},{},{1,5,9}} :: {{int}}
	
	> part({{F,T},{T},{}bool, {F,F}}, {F,F,T,F,F,T})
	{{{F,T},{T}},{{},{F,F}}} :: {{{bool}}}
	\end{lstlisting}
	\end{figure}
	
	\item $\*{scan_+}: \{\int\} \ra \{\int\}$, performs an exclusive scan of plus operation on the given sequence.
	\begin{figure}[H]
	\begin{example}
	\end{example}
	\begin{lstlisting}[style = nesl-style]
	> scanPlus({3,1,4,1})
	{0,3,4,8} :: {int}
	
	> scanPlus({}int)
	{} :: {int}
	\end{lstlisting}
	\end{figure}
	
	\item $\*{reduce_+: \{\int\} \ra \int }$, performs a reduction of plus operation on the given sequence, i.e., compute its sum.
	\begin{figure}[H]
	\begin{example}
	\end{example}
	\begin{lstlisting}[style = nesl-style]
	> reducePlus({3,1,4,1})
	9 :: int
	
	> reducePlus({}int)
	0 :: int
	\end{lstlisting}
	\end{figure}


	\item $\*{the:  \{\tau\} \ra \tau}$, returns the element of a singleton sequence.
	\begin{figure}[H]
	\begin{example}
	\end{example}
	\begin{lstlisting}[style = nesl-style]
	> the({3})
	3 :: int
	
	> the({(3,1)})
	(3,1) :: (int,int)
	\end{lstlisting}
	\end{figure}
	
	\item $\*{empty:  \{\tau\} \ra \bool}$, tests if the given sequence is empty.
	\begin{figure}[H]
	\begin{example}
	\end{example}
	\begin{lstlisting}[style = nesl-style]
	> empty({3,1,4,1})
	F :: bool
	
	> empty({}int)
	T :: bool
	\end{lstlisting}
	\end{figure}
\end{itemize}



\begin{figure}[H]\large
	\begin{example}\emph{A user-defined function  written in SNESL1 to compute the multiplication of a square matrix and its transpose.}
	\end{example}
	\begin{lstlisting}[style = nesl-style]
	-- code desplay format changed for readability
	function matmul(n:int) :{{int}} = 
  	  let matA = {&n : _ in &n};
	      matB = {{x : _ in &n} : x in &n} -- transposition of matA
	  in {{ reducePlus({x*y : x in a, y in b}) : a in matA} : b in matB}
	
	> matmul(4)
	{{0,0,0,0},{6,6,6,6},{12,12,12,12},{18,18,18,18}} :: {{int}}
	\end{lstlisting}
\end{figure}





\section{SVCODE}
In \cite{Fmaster} a streaming target language for a minimal SNESL was defined.
With trivial changes in the instruction set, this language, named as SVCODE (Streaming VCODE), has been implemented on a multicore system in \cite{Fphd}; the various experiment results
have demonstrated single-core performance similar to sequential C code for some simple 
text-processing tasks as well as the
potential for further performance improvment by scheduling opitmization and code analysis.

In this thesis, we put emphasis on the formalization of this low-level language's semantics.
Also, to support recursion in the high-level language at the same time preserving the cost, non-trivial extension of this language is needed. 

\subsection{SVCODE Syntax}
The primitive data structure that SVCODE manipulates, called $stream$, is similar to the one-dimensional array in C language; the main difference is that the elements of a stream can
be collected through not only a piece of memory, but also a period of time. 

%TODO: add figure of comparison ?

For our minimal language, a primitive stream $\a$ can be a stream of booleans, integers or units, as the following grammar shows:

$$b \in \mathbb{B} = \{\T,\F \}$$
$$ a ::= n \ | \ b \ | \ \unit$$
$$\b = \vrange{b_1}{b_i}$$ 
$$\c = \vrange{()}{()} $$
$$\a = \vrange{a_1}{a_i}  $$ 

\hspace{1cm}



The grammar of SVCODE is given in Figure~\ref{fig-svcode1-gram}.
An SVCODE program is basically a list of command or instructions of ecah defines one or more new streams. 
As a general rule of reading an SVCODE instruction, the stream ids on the left-hand side of a symbol ``:=" are the defined streams, and the right-hand side ones are possibly used to generate those new ones.


\begin{figure}[!h] \large
	\begin{alignat*}{2}
	&p  && :: = \ \epsilon \tag{empty program}\\ 
	&   && \quad | \ \sdef{\s}{\psi(s_1,...,s_k)}  \tag{single stream definition}\\
	&   && \quad | \ \withctrl{\s}{p_1}{\Sin}{\Sout}  \tag{\wc block}\\
	&   && \quad | \ \scall{f}{\S_1}{\S_2} \tag{SVCODE function call}\\
	&   && \quad | \ p_1;p_2  \\
	\\
	&\s && ::= 0 \ | \ 1 \ ... \in \SId  = \mathbb{N}   \tag{stream ids}\\
	\\
	& \psi \ && ::= \consta{a} \ | \ \toflag  
	\ | \ \usum \ | \ \map{\oplus} \ | \ \genscan_{\otimes} \ | \ \genreduce_{\otimes} \ | \ \distr  \tag{Xducers}  \\
    &   && \quad | \ \pack \ | \ \upack \ | \ \bu \ | \ \segconcat \ | \ \usegcount \ | \ \intermerge \ | \ ...  \\
    & \oplus  \ && :: = + \ | \ - \ | \ \times \ |  \  \div \ | \ \% \ | \le \ | \ ... \tag{consts operations} \\
    & \otimes \ && :: = + \ | \ \times  \ | \ ...  \tag{associative binary operations} \\
	\\
	&  \S && ::= \{\s_1,..., \s_i\} \in \sset  \tag{set of stream ids}\\
	\end{alignat*}
	\caption{Grammar of SVCODE \label{fig-svcode1-gram}}
\end{figure}

A well-formed SVCODE instruction is expected to always assign $fresh$ stream ids to the defined streams, in which way the dataflow of an SVCODE program can construct a DAG (directed acyclic graph). 
We will give more formal definitions of this language in the next chapter
to demonstrate how we guarantee the freshness of stream ids. 
In the practical implementation, we simply identify each stream with a natural number, a smaller one always defined eariler than a greater one. 

The primitive instructions in SVCODE that define only one stream are in the form
$$\sdef{\s}{\psi(s_1,...,s_k)} $$  
where $\lcall$ is a primitive function, called a $Xducer$(transducer), taking stream $s_1,...,s_k$ as parameters and returning $s$. 

The only essential control struture in SVCODE is the \wc instruction 
$$\withctrl{\s}{p_1}{\Sin}{\Sout} $$
which may or may not execute a piece of SVCODE program $p_1$, but always defines a bunch of stream ids $\Sout$.
$\s$ is the new control stream used when the code block $p_1$ is executed, and $\Sin$ is the set of stream ids that can be used in $p_1$. 
Discussions about this
instruction will occur many times throughout the thesis as it plays a significant role in dealing with most of the issues we are deeply concerned, 
including cost model correctness and dynamic unfolding of recursive functions. 


%The rules $\PName{Wc-Emp}$ and $\PName{Wc-Nonemp}$ together show two possibilities for interpreting a \wc instruction:
%\begin{itemize}
%	\item if the new control stream $\s_c$ as well as the streams in $\Sin$, which includes the free variables of $p_1$, are all empty, then just bind empty vectors to the streams in $\Sout$, which are part of the defined streams of $p_1$.
%	\item otherwise execute the code of $p_1$ as usual under the new control stream, ending in the store $\sgm''$; then copy the bindings of $\Sout$ from $\sgm''$ to the initial store. 
%\end{itemize}
%The new control stream is crucial here, because it decides whether or not to execute $p_1$, which is the key to avoiding infinite unfolding of recursive funtions. For an eager interpreter of SVCODE, if we count one stream definition as one step, then this skip guarantees the low-level step cost agrees on the high-level one. Also, skipping a certain piece of code should help improve the efficiency of execution.



As the high-level language supports recursive functions, the function body must be unfolded dynamically in runtime. 
A recursive call should be included in some condition statement to decide when the recursion can terminate, which is impossible to do during compiling time. 
The instruction $\scall{f}{\S_1}{\S_2}$ can be read as: ``calling function $f$ with arguments $\S_1$ returns $\S_2$".

(may add more informal explanation of SVCODE semantics)

%We introduce some notations and operations about streams for convenience.
%\begin{nota}
%	Let $\< a_0 | \a \'>$ denote a non-empty stream $\< a_0,a_1,...,a_i \'>$ for some $\a = \< a_1,...,a_i \'>$. 
%\end{nota}
%
%
%\begin{nota}[\textbf{Stream concatenation}]
%	$\vapp{\vrange{a_1}{a_i}} {\vrange{a_1'}{a_j'}} = \langle a_1,...,a_i,a_1',...,a_j' \rangle $ \\
%	
%\end{nota}
%
%The operational semantics of SVCODE is given in Figure~\ref{fig-svcode-semantics}.
%The runtime environment or store $\sgm$ is a map from stream variables to vectors:
%$$\sgm = [\s_1 \|-> {\a_1},...,\s_i \|-> {\a_i}]$$
%The $control \ stream$ $\c$, which is basically a vector of units representing an unary number, indicates the $parallel \ degree$ of the computation. The role of control stream will become much clearer when we come to the semantics of Xducers. It is worth noting that only in the rule $\PName{Wc-Nonemp}$ the control stream has a chance to get changed.


\subsection{Xducers and dataflow}

Transducers or $Xducers$ are the primitive functions performing transformation on streams in SVCODE. Each Xducer consumes a number of streams and transforms them into another. 

For example, the Xducer $\map{+}(\<3,2\'>, \< 1,1\'>)$ consumes the stream $\<3,2\'>$ and $\< 1,1\'>$, then outputs 
the element-wise addition result $\<4, 3\'>$. 

\begin{example} \emph{$\map{+}(\<3,2\'>, \< 1,1\'>)$:}\\
	\begin{center}
		\includegraphics[width=0.6\textwidth]{fig/map.png}
	\end{center}
\end{example}


%the Xducer $\constaf{a}$ outputs the const $a$ until the control stream reaches EOS.
%
%\begin{example} \emph{$\constaf{3}$ with control stream $\c = \<(),()\'>$:}\\
%	\begin{center}
%		\includegraphics[width=0.6\textwidth]{fig/const3.png}
%	\end{center}
%\end{example}

	

As we have mentioned before, the dataflow of an SVCODE program is basically a DAG, where each Xducer stands for one node. 
The \wc block is only a subgraph that may be added to the DAG at runtime,  
and \sc another that will be unfolded dynamically.

Figure~\ref{fig-svcode-eg1} shows an example program, with its DAG in Figure~\ref{fig-svcode-dag1}. \\

\begin{figure}[H]
	\begin{lstlisting}[style=svcode-style]
	S1 := Const_3();
	S2 := ToFlags(S1);
	S3 := Usum(S2);
	[S4] := WithCtrl(S3,[], 
	          S4 := Const_1();
	        )
	S5 := ScanPlus(S2, S4);
	\end{lstlisting}	
	\caption{A small SVCODE program \label{fig-svcode-eg1}}
\end{figure}
%	S6 := Usum(S2);
%	[S7] := WithCtrl(S6, [S5], 
%	[S7] := SCall(plus1, [S5])
%	)
\hspace{1cm}

\fig{\includegraphics[width=1.1\textwidth]{fig/xducerDag2.png}}{
	Dataflow DAG for the code in Figure~\ref{fig-svcode-eg1} (assuming S3 is nonempty).
	\label{fig-svcode-dag1}
	Note that, for simplicity, the control stream is added as an explicit supplier only to Xducer $\consta{a}$.
}


When we talk about two Xducers $A$ and $B$ connected by an arrow from $A$ to $B$ in the DAG, we call $A$ a $producer$ or a $supplier$ to $B$, and $B$ a $consumer$ or a $client$ of $A$. 
As an Xducer can have multiple suppliers, we distinguish these suppliers by giving each of them an index, called a $channel \ number$. 
In Figure~\ref{fig-svcode-dag1}, the channel number is labeled above each edge. 
For example, the Xducer S2 has two clients, S3 and S5, for both of whom it is the No.0 channel;  Xducer S5 has two suppliers: S2 the No.0 channel and S3 the No.1. 




\section{Value representation}
In SVCODE, the data structures are only primitive streams and pairs of streams. 
To support the various high-level value types, that is, to design streamable counterparts to all the values of SNESL1, some technical transformation is necessary.  
The technique is similar to the idea described in \cite{prins93}, but the descriptors in SVCODE are boolean streams instread of interger ones.

%First we can only consider the representations of high-level values without pairs.
\begin{itemize}
	\item A const is represented as a singleton stream. 
	\begin{example}
		$$3 \tr_\int \ \< 3 \'>$$
		$$ \T \tr_\bool \oT $$
	\end{example}
	
	
	
	\item A non-nested primitive sequence of length $n$ is represented as a primitive data stream with an auxiliary boolean stream called a $descriptor$, which consists of $n$ number of $\F$s and one $\T$. 
	\begin{example}
		$$\{3,1,4\} \tr_{\{\int\}} (\< 3,1,4 \'>, \< \F, \F,\F , \T \'>) $$
	    $$\{\T,\F\} \tr_{\{\bool\}} (\< \T,\F\'>, \< \F,\F , \T \'>) $$
		$$\{\}\int \tr_{\{\int \}} (\emptyv, \oT)$$
	\end{example}
	
	\item For a nested sequence with a nesting depth $d$, all the data are flattened to one data stream, but $d$ descriptors are used to represent the segments at each depth. 
	Thus a non-nested sequence is just a special case of depth $d$ = 1.
	
	\begin{example}
		$$\{\{3,1\}, \{4\}\} \tr_{\{\{\int\}\}} ((\< 3,1,4 \'>, \<\F,\F,\T,\F,\T \'>),\< \F, \F, \T \'>)  $$
		$$\{\}\{\int\} \tr_{\{\{\int\}\}} ((\emptyv, \emptyv), \oT)$$
	\end{example}
	
%	\item A sequence is transformed to a primitive data stream with a number of boolean streams representing the dimension or the nested depth of the sequence. 
%	These boolean streams are called $descriptors$ because the 
%	
%\end{itemize}
%
%Now we consider pairs being added.
%\begin{itemize}

\item A high-level pair is a pair of streams at the low level.  
\begin{example}
	$$(1,2) \tr (\singl{1}, \singl{2})$$
\end{example} 

(will add one or two examples about sequence of pairs and some explainations)
\end{itemize}

\section{Translating SNESL1 to SVCODE}
As we have seen in the last section, a high-level sequence corresponds to a number of low-level streams.
We use a structure $\STree$ (stream tree) to generalize the relation between the high-level values and the low-level streams during compiling time:
$$ \STree \ni \st ::= \s \ | \ (\st_1,\st_2) $$
Thus a stream tree is a binary tree whose leaves are stream ids.  

The translation environment $\del$ is a mapping from high-level variables to stream trees:
 $$\del = [x_1 \|-> \st_1,..., x_i \|-> {\st_i}] $$ 

Another essential component maintained in the translation procedure is an unused stream id called the next fresh id because it will be assigned to the defined stream(s) of the next generated instruction.

\subsection{Expression translation}

%	 Convert a stream tree to a list of  stream ids:
%	\begin{align*}
%	&\bar{}: \STree \-> \S \\
%	&\overline{\s} = [s] \\
%	&\overline{(\st,s)} = \overline{st} {\++} [s]
%	\end{align*}
%	
The translation rules for SNESL1 expressions is shown in Figure~\ref{fig-trans-snesl1}. 
The jugement can be read as: `` in the environment $\del$, the expression $e$ is translated to an SVCODE program $p$, whose stream ids starts from $s_0$ and ends at $s_1-1$ (both included), and the evaluatation result corresponds to $\st$". 


(should have more fixes and informal explanations in the rest of this section)

\fig{
 \Jug{\Trans{\del}{e}{\s_0}{\s_1}{\sfun{p}{\st}}}

	\PT{\Axiom{\Trans{\del}{a}{\s_0}{\s_0+1}{\sfun{\sdef{s_0}{\constaf{a}}}{\s_0}}}}
	\PT{\AC{}
		\RiLa{(\del(x)= \st)}
		\UC{\Trans{\del}{x}{\s_0}{\s_0}{\sfun{\epsilon}{\st}}}
	}\\[3ex]
	
	\PT{\AC{\Trans{\del}{e_1}{\s_0}{\s_0'}{\sfun{p_1}{\st_1}}}
		\AC{\Trans{\del}{e_2}{\s_0'}{\s_1}{\sfun{p_2}{\st_2}}}
		\BC{\Trans{\del}{(e_1,e_2)}{\s_0}{\s_1}{\sfun {p_1;p_2} {(\st_1,\st_2)}}}
	}\\[3ex]

	\PT{\AC{\Trans{\del}{e_1}{\s_0}{\s_0'}{\sfun{p_1}{\st_1}}}
		\AC{\Trans{\del[x \|-> {\st_1}]}{e_2}{\s_0'}{\s_1}{\sfun {p_2} {\st}}}
		\BC{\Trans{\del}{\Let{x}{e_1}{e_2}}{\s_0}{\s_1}{\sfun {p_1;p_2} {\st}}}
	}\\[3ex]

	\PT{
		\AC{\Transf{\hcall}{\replc{k}{st}}{\s_0}{\s_1}{\sfun{p}{\st}}}
		\RiLa{((\del(x_i)=\st_i)^k_{i=1})}
		\UC{\Trans{\del}{\hcall \Tupk{x}}{\s_0}{\s_1}{\sfun{p}{\st}}}
	}\\[5ex]

%TODO: fix and add more 	
	???! TODO:fix
	\PT{
		\AC{\Trans{[x \|-> {\st_1}, \j{x_i \|-> \st_i}]}{e}{\s_0+1+j}{\s_1}{\sfun{p_1}{\st}}}
		\RiLa{\left(
			\begin{aligned}
				\del(y) = &  \ (\st_1,\s_b) \\
				\j{\del(x_i) = & \ \st_i'} \\
				p = & \ \sdef{\s_0}{\usum(\s_b)}; \\
				& \ \j{\sdef{\s_i}{\distrf{\s_b}{\s_i'}};} \\
				& \ \withctrl{\s_0}{p_1}{\Sin}{\Sout} \\
				\Sin = &  \ \FV{p_1} \\
				\Sout = & \ \overline{\st} \cap \dv{p_1} \\
				\s_{i+1} = & \ \s_i + 1, \forall i \in \{0,...,j-1\} \\
			\end{aligned}
			\right)}
		\UC{\Trans{\del}{\Comp{e}{x}{y}{\usevars}}{\s_0}{\s_1}
			{ \sfun{p} {(\st,\s_b)}}}
	}\\[10ex]	
}{Translation rules for SNESL1 expressions \label{fig-trans-snesl1}}
	
% Auxiliary 


\subsection{Built-in function translation}
The function call of a high-level built-in function will be translated to a few lines of SVCODE instuctions.

\fig{
\Jug{\Transf{\hcall}{\replc{k}{st}}{\s_0}{\s_1}{\sfun{p}{\st}}} 
			
	\PT{
		\Axiom{\Transf{\oplus}{\s_1,...,s_k}{\s_0}{\s_0+1}
			\sfun{\sdef{\s_0}{\map{\oplus}(\s_1,...,\s_k)}}{\s_0}}
	}\\[10ex]
	\PT{
		\AC{}
		\RiLa{\left( \begin{aligned}
				\s_{i+1} & = \s_i + 1, \forall i \in \{0,...,3\} \\
				p= & \sdef{\s_0}{\toflag(\s)} ; \\ 
				& \sdef{\s_1}{\usum(s_0)} ; \\
				& \withctrl{\s_1}{\sdef{\s_2}{\consta{1}()}}{[\s_1]}{[\s_2]}; \\
				& \sdef{\s_3}{\scan_{0}(\s_0,s_2)}
			\end{aligned}\right)
		}
		\UC{\Transf{\iotan}{\s}{\s_0}{\s_4}{\sfun{p} {(\s_3,\s_0)}}}
	}\\[4ex]
(will add more)
%TODO add more
}{Translation of built-in functions \label{fig-trans-builtin}}


\subsection{User-defined function translation}
A user-defined function $function \  f(x_1: \tau_1, ..., x_k: \tau_k): \tau = e $ will be translated to an SVCODE function
$([\S_1], p, \ol{\st})$, where $\Trans{[x_1 \|-> st_1,..., x_k \|-> \st_k ]}{e}{0}{s_1}{\sfun{p}{\st}}$ and ...
$$ tp2tree : \tau \ra \STree  $$ 
%TODO 


\section{Eager interpreter}
Recall that an SVCODE program is a list of instructions of each defines one or more streams. 
The eager interpreter executes the instructions sequentially, assuming the available memory is infinitely large, which is the critical difference between the execution models of the eager and streaming interpreters.
For an eager interpreter, since there is always enough space, a new defined stream can be completely allocated in memory immediately after its definition instruction is executed.
In this way, traversing the whole program only once will generate the final result, even for recursions.
And the streaming model of SVCODE does not show any of its strengths here; the interpreter will perform just like a NESL's low-level interpreter. 

\subsection{Dataflow}

\subsection{Cost model}



\section{Streaming interpreter}
As we have mentioned before, the execution model of streaming interpreter does not assume an infinite memory; instead, it only uses a limited size of memory as a buffer. 
If the buffer size is relatively small, then most of the streams cannot be materialized entirely at once. 
As a result, the SVCODE program will be traversed multiple times, or there will be more scheduling rounds. 
The dataflow of the streaming execution model is still a DAG, but the difference from the eager one is that each Xducer maintains a small buffer, whose data is updated each round. 
The final result will be collected from all these scheduling rounds.

Since in most cases we will have to execute more rounds, some extra setting-up and overhead seem to be inevitable.
On the other hand, exploiting only a limited buffer increases the efficiency of space usage. 
In particular, for some streamable cases, such as an exclusive scan, the buffer size can be as small as one (and by one we do not mean one bit or byte of physical memory, but rather a conceptual, minimal size).


\subsection{Processes}
In the streaming execution model, the buffer of a Xducer can be written only by the Xducer itself, but can be read by many other Xducers. 
And it has two states: 
\begin{description}
	\item[Filling state]: the buffer is not full, and the Xducer is producing or writing data to it; any other trying to read it has to wait, or more precisely, enters a read-block state.

	\item[Draining state]: the buffer must be full; the readers, including the read-blocked ones, can start reading it now; if the Xducer tries to write the buffer, then it enters a write-block state.
\end{description}

The condition of switching from filling state to draining state is simple: when the buffer is fully filled. 
But the other switching direction takes a bit more work to detect: all the readers have read all the data in the buffer. We will come to this later.

A notable special case is when the Xducer produces its last chunk, whose size may be less than the buffer size thus can never turn the buffer to a draining mode.
To deal with this case, we add a flag to the draining state to indicate if it is the last chunk of the stream. 
So we define the buffer state as follows:
$$\bufst = \{\*{Filling}, \*{Draining} \ b \} $$


In addition to maintaining the buffer state, the Xducer also has to remember its suppliers so that it is not necessary to specify the suppliers repeatedly each round. 
Actually, once a dataflow DAG is established, it is only possible to add more subgraphs to it due to an unfolding of a \wc block or a \sc instruction; the other parts uninvolved will be unchanged until the execution is done.


Since Xducers have different data rates (the size of consumed/produced data at each round), it is also important to keep track of the position of the data that has been read, which can be represented by an integer.
Also, it is possible that a Xducer reads from the same supplier multiple times but with different data rates, in which case only a pair of stream id and an integer is not enough to distinguish all the different read cursors. 
Thus we need a third component, the channel number, to record the state of each reader, as we have shown in Figure~\ref{fig-svcode-dag1}.
As a result, we must have a client list $\clis$ of elements of type $(\SId, \int, \int) $

Now we define a $process$, a tuple of four components including a Xducer, as the node on the streaming DAG:

$$ \proc  =  (\bufst, \S, \clis, \xducer) $$

where $\S$ is the stream ids of the suppliers. 



\subsection{Scheduling}


\subsection{Recursion}

\subsection{Deadlock}

\subsection{Examples}

%Figure~\ref{fig-xducer-semantics} shows the semantics at the general level. 
%
%
%\begin{figure}[h]\large
%	
%	\Jug{\sevalf{\a_1}{\a_k}{\c}{\a}} \\
%	
%	
%	\PRule{X-Loop}{\PT{
%			\AC{\block{\a_{11}}{\a_{k1}}{\a_{01}}}
%			\AC{\sevalf{\a_{12}}{\a_{k2}}{\c_0}{\a_{02}}}
%			\RiLa{((\vapp{\a_{i1}}{\a_{i2} = \a_i})^k_{i=0})}
%			\BC{\sevalf{\a_1}{\a_k}{\< () | \c_0 \rangle}{\a_0}}
%	}}\\[4ex]
%	
%	\LeLa{\PName{X-Termi:}} 
%	\Axiom{\sevalf {\emptyv_1} {\emptyv_k} \emptyv \emptyv}
%	\DisplayProof \footnotemark	
%	\caption{Semantics of SVCODE transducers \label{fig-xducer-semantics}}
%\end{figure}
%\footnotetext{For notational convenience, in this thesis we add subscripts to a sequence of constants, such as $\emptyv, \F, 1$, to denote the total number of these constants.}
%
%There are only two rules for the general semantics. 
%They together say that the output stream is computed in a ``loop" fashion, where the 
%iteration uses specific block semantics of the Xducer and the number of iteration is the unary number that the control stream represents, i.e., the length of the control stream. 
%In the parallel setting, we prefer to call this iteration a $block$. 
%Recall the control stream is a representation of the parallel degree of the computation, then a block consumes exact one degree. 
%We note that all these blocks are data-independent, which means they can be performed in parallel. 
%Now it is clear that the control stream indeed carrys the theoretical
%maximum number of processors we need to execute the computation most efficiently (if the computation within the block can not be parallelized further)(???).
%
%\begin{itemize}
%\renewcommand{\labelitemi}{$-$}
%
%	\item $\toflagf{\singl{n}}$ first outputs $n$ $\F$s, then one $\T$.
%	
%	\begin{example} \emph{$\toflagf{\<2,0\'>}$:}\\
%		\begin{center}
%		\includegraphics[width=0.6\textwidth]{fig/toflag.png}
%		\end{center}
%	\end{example}
%
%	\item $\usumf{\b}$ transforms an $\F$ to a unit, or a $\T$ to nothing. It is the only Xducer that can generate a unit vector,
%	so it is mainly used when we need to replace the control stream.
%	\begin{example} \emph{$\usumf{\<\F,\T,\F,\F,\T\'>}$:}\\
%		\begin{center}
%			\includegraphics[width=0.6\textwidth]{fig/usum.png}
%		\end{center}
%	\end{example}
%	
%	\item $\scan_{n_0}(\b,\a)$ performs an exclusive scan of the binary operation plus on $\a$, segmented by $\b$, with a starting element $n_0$.
%		\begin{example} \emph{$\scan_{0}(\<\F,\F,\F,\T,\F,\T\'>, \< 2,5,3,6 \'>)$}\\
%		\begin{center}
%			\includegraphics[width=0.7\textwidth]{fig/scan.png}
%		\end{center}
%	\end{example}
%	 
%	\item $\distr(\b,{\singl{n}})$ replictes the const $n$ $u$ times where $u$ is the unary number segmented by $b$. 
%	\begin{example} \emph{$\distrf{\<\F,\F,\F,\T,\F,\T\'>}{\< 2,5 \'>}$}\\
%		\begin{center}
%			\includegraphics[width=0.7\textwidth]{fig/distr.png}
%		\end{center}
%	\end{example}
%	
%\end{itemize}
%
%		
%
%
%As we have discussed before, we consider a block  as the minimum computing unit assigned to a single processor. This is reasonable for
%Xducers such as $\consta{a}$ and $\maptwo{\oplus}$, because
%they are already sequential at the block level. 
%
%However, some other Xducers, such as $\usum$, can be parallelized further inside a block.
%As we extend the language with more Xducers, we could find that computations on unary numbers within blocks are common, which is mainly due to the value represenation strategy we use, but also more difficult to be regularized.
%For the scope of this thesis, the block semantics we have shown are already relatively clear and simple enough to reason about, and the unary level parallelism can be investegated in future work. 
% 


