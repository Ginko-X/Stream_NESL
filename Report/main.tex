\documentclass[a4paper]{report}


\usepackage{amsmath, amssymb, amsthm}
\usepackage{mathtools}
\usepackage{proof}
\usepackage{bussproofs}
\usepackage{color}
\usepackage{geometry}
\usepackage{enumerate}
\usepackage{extarrows}
\usepackage{verbatim}
\usepackage[ampersand]{easylist}
\usepackage[linewidth=1pt]{mdframed}
%\usepackage{tcolorbox}
\usepackage[font=large,labelfont=bf]{caption}
\usepackage{float}
\usepackage{diagbox}
\usepackage{pdfpages}

\geometry{left=3cm,right=3cm,top=3cm,bottom=3cm}

\renewcommand\qedsymbol{$\blacksquare$}

\newtheorem{thm}{Theorem}[chapter]
\newtheorem{lem}[thm]{Lemma}
\newtheorem{defi}[thm]{Definition}
\newtheorem{nota}[thm]{Notation}
\newtheorem{prop}[thm]{Proposition}
\newtheorem{cor}[thm]{Corollary}

\newtheorem{example}{Example}[chapter]


\usepackage{listings}
\definecolor{blue}{rgb}{0.0, 0.0, 1.0}
\definecolor{lbcolor}{rgb}{0.9,0.9,0.9}
\definecolor{darkgreen}{rgb}{0.0, 0.42, 0.24}
\definecolor{darkblue}{rgb}{0,0,1}
\definecolor{amber}{rgb}{1.0, 0.75, 0.0}
\definecolor{coolblack}{rgb}{0.0, 0.18, 0.39}
\definecolor{carnelian}{rgb}{0.7, 0.11, 0.11}
\definecolor{gray}{rgb}{0.3,0.3,0.3}
\definecolor{blue(munsell)}{rgb}{0.0, 0.5, 0.69}
\definecolor{darkred}{rgb}{0.5, 0.0, 0.13}
\definecolor{auburn}{rgb}{0.43, 0.21, 0.1}

\input{lang-style.tex}

\lstset{
	basicstyle=\normalsize\ttfamily,
	breakatwhitespace=true,
	breaklines=true,
	captionpos=t,
	columns=fixed,
	extendedchars=true,
	commentstyle=\color{darkgreen},
	frame=single,
	frameround=tttt,
	framesep=4pt,
	keywordstyle=\bfseries\color{carnelian},
	numbers=left,
	numberstyle=\scriptsize\color{gray},
	rulecolor=\color{black},
	showstringspaces=false,
	showtabs=false,
	stepnumber=1,
}



\def\*#1{\mathbf{#1}}



%source language syntax
\def\Let#1#2#3{\*{let} \ #1 = #2 \ \*{in} \ #3}
\def\Comp#1#2#3#4{\{#1 : #2 \ \*{in} \ #3 \ \*{using} \ #4\}}
\def\RComp#1#2#3{\{ #1 \ | \ #2 \ \*{using} \ #3 \}}

\def\hcall{\phi} 

\def\usevars{x_1,...,x_j}
\def\usevarsk{x_1,...,x_k}
\def\j#1{(#1)^j_{i=1}}
\def\k#1{(#1)^k_{i=1}}
\def\l#1{(#1)^l_{i=1}}

\def\const#1{\*{const}_{#1} ()}
\def\iota#1{\*{iota} (#1)} 
\def\plus#1#2{\*{plus} (#1,#2)}

\def\constn#1{\*{const}_{#1}}
\def\iotan{\*{iota}} 
\def\plusn{\*{plus}}


%types
\def\int{\*{int}}
\def\bool{\*{bool}} 
\def\tseq#1{\{#1\}}  


% symbol shorthands
\def\Eva{\downarrow}
\def\Ra{\Rightarrow}
\def\Env{\ \vdash\ } 

\def\Seqk#1{\{ #1_1,...,#1_k \}}
\def\Tupk#1{(#1_1,...,#1_k)}
\def\replc#1#2{#2_1,...,#2_{#1}}

% greek letters
\def\sgm{\sigma}
\def\Gam{\Gamma}
\def\del{\delta}


% special font

\def\MC{\mathcal{C}}  % translation
\def\ME{\mathcal{E}}  % snesl evaluation
\def\MP{\mathcal{P}}  % svcode semantics
\def\MT{\mathcal{T}}  % typing rules
\def\MR{\mathcal{R}}  % value representation


% Judgment
\def\Jug#1{\textbf{Judgment} \boxed{#1} \\[1ex]}

\def\Map#1#2{#1 \mapsto #2}
 

% Evaluation
\def\Eval#1#2#3{#1 \Env #2 \Eva #3 } 
\def\EvalF#1#2#3{#1(#2) \Eva #3}  % function evaluation

%typing
\def\Type#1#2#3{#1 \Env #2 : #3 } 
\def\Typef#1#2#3{#1 : (#2) \rightarrow #3}
\def\TypeV#1#2{#1 : #2}

%value representation
\def\ValRep#1#2#3{ #1 \triangleright_{#2} #3}


% rule with a name
\def\ERule#1#2{$\textsc{E-#1} : {#2}$}
\def\CRule#1#2{$\textsc{C-#1} : {#2}$}
\def\PRule#1#2{$\textsc{P-#1} : {#2}$}


% only rule name
\def\EName#1{\textsc{E-#1}}
\def\PName#1{\textsc{P-#1}}
\def\CName#1{\textsc{C-#1}}

%proof tree shorthands
\def\AC#1{\AxiomC{$#1$}}
\def\Axiom#1{\AxiomC{} \UnaryInfC{$#1$}}
\def\UC#1{\UnaryInfC{$#1$}}
\def\BC#1{\BinaryInfC{$#1$}}
\def\TC#1{\TrinaryInfC{$#1$}}
\def\DP{\DisplayProof}
\def\LeLa#1{\LeftLabel{$#1$}}
\def\RiLa#1{\RightLabel{$#1$}}
\def\PT#1{#1 \DisplayProof \qquad} 
%UnaryInfC with a deriviation name
\def\UCN#1#2{\AxiomC{$#1$} \noLine \UC{#2}}


%shorhands notations
\def\<{\langle} 
\def\'>{\rangle}
\def\->{\rightarrow}
\def\=>{\Rightarrow}

\def\ConEq#1{\xlongequal{<#1}}  % Sgm conditional equation
\def\.<{\lessdot}
\def\bs{ \ \backslash \ } 


\def\unit{()}
\def\vunit{\langle \unit \rangle}  

\def\vrange#1#2{\langle #1,...,#2 \rangle}
\def\lrange#1#2{\left[ #1,...,#2 \right]}

\def\emptyv{\langle \rangle}

\def\prefix{\sqsubseteq}


\def\s{\mathit{s}}  
\def\st{\mathit{st}} 
\def\SId{\mathbf{SId}}
\def\STree{\mathbf{STree}}

\def\sset{\mathbb{S}}
\def\S{S}
\def\Sin{S_{in}}
\def\Sout{S_{out}}

\def\FV#1{\mathtt{fv}(#1)}
\def\dv#1{\mathtt{dv}(#1)}


\def\v{w}
\def\a{\vec a}
\def\b{\vec b}
\def\c{\vec c}

\def\SvVal{\mathbf{SvVal}}

%\def\ctrl{\mathtt{Ctrl}}
\def\consta#1{\mathtt{Const_{#1}}} 
\def\toflag{\mathtt{ToFlags}}
\def\usum{\mathtt{Usum}}
\def\maptwo#1{\mathtt{MapTwo}_{#1}}
\def\map#1{\mathtt{Map}_{#1}}

\def\scan{\mathtt{ScanPlus}}

\def\genscan{\mathtt{Scan}}
\def\genreduce{\mathtt{Reduce}}

\def\distr{\mathtt{Distr}}
\def\pack{\mathtt{Pack}}
\def\upack{\mathtt{UPack}}
\def\bu{\mathtt{B2u}}
\def\segconcat{\mathtt{SegConcat}}
\def\usegcount{\mathtt{USegCount}}
\def\intermerge{\mathtt{InterMerge}}
\def\seginter{\mathtt{SegInter}}
\def\primseginter{\mathtt{PrimSegInter}}
\def\check{\mathtt{Check}}
\def\isempty{\mathtt{IsEmpty}}
\def\emptyctrl{\mathtt{EmptyCtrl}}


\def\constaf#1{\mathtt{Const_{#1}()}} 
\def\toflagf#1{\mathtt{ToFlags}(#1)}
\def\usumf#1{\mathtt{Usum}(#1)}
\def\maptwof#1#2#3{\mathtt{MapTwo}_{#1}(#2,#3)}
\def\scanf#1#2{\mathtt{ScanPlus}(#1,#2)}
\def\distrf#1#2{\mathtt{Distr}(#1,#2)}
\def\packf#1#2{\mathtt{Pack}(#1,#2)}
\def\upackf#1#2{\mathtt{UPack}(#1,#2)}

\def\:={:=}
\def\sdef#1#2{#1 := #2}
\def\withctrl#1#2#3#4{#4 := \mathtt{WithCtrl}(#1,#3,#2)}
\def\wc{$\mathtt{WithCtrl}$ }
\def\sc{$\mathtt{SCall}$ }
\def\scall#1#2#3{#3 := \mathtt{SCall} \ #1(#2)} 
\def\sf{$\mathtt{SFun}$}

\def\T{\mathtt{T}} 
\def\F{\mathtt{F}} 
\def\oT{\singl{\T}}
\def\oF{\singl{\F}}

\def\sids#1{\mathtt{sids}(#1)}
\def\ol#1{\overline{#1}}

\def\++{+\!+}
\def\vapp#1#2{#1 {\++} #2}


\def\~#1{\stackrel{#1}{\sim}}
\def\x#1{\stackrel{#1}{\bowtie}} % sgm append

\newcommand\ra{\rightarrow}
\def\Da{\Downarrow}
\def\dda{\downdownarrows}

\def\lcall{\psi} 
\def\seval#1#2#3#4{\left\langle#1,#2 \right\rangle \Da^{#3} #4} 
\def\sevalf#1#2#3#4{{\lcall}(#1,...,#2) \Da^{#3} #4}
\def\sevalfg#1#2#3#4{#1(#2) \Da^{#3} #4}

\def\block#1#2#3{{\lcall}(#1,...,#2) \Eva #3}  
\def\blockf#1#2#3{#1(#2) \Eva #3} 
\def\unary#1#2#3{{\lcall}(#1,...,#2) \dda #3}

\def\blockv#1#2#3#4{\lcall_{#1}(#2,...,#3) \Eva #4}  
\def\unaryv#1#2#3#4#5{\lcall_{#1}(#2,...,#3) \dda^{#4} #5}

\def\singl#1{\langle #1 \rangle}
\def\|->{\mapsto}   % map 
\def\>->{\rightarrowtail} % map a bunch of variables
%\def\=>#1#2{\Rightarrow^{#1}_{#2}}


%translation
\def\sfun#1#2{(#1,#2)}

% compiling/translation
\def\Trans#1#2#3#4#5{#1 \Env #2 \Rightarrow^{#3}_{#4} #5}
\def\Transf#1#2#3#4#5{#1(#2) \Rightarrow^{#3}_{#4} #5}


\numberwithin{equation}{chapter}
\numberwithin{figure}{chapter}


\newcommand{\eq}[2]{\begin{equation}\label{#1} #2\end{equation}}

\newcommand{\fig}[2]{\begin{figure}[H]\large #1 \caption{#2}\end{figure}}



\title{Formalizing the implementation of Streaming NESL}
\author{Dandan Xue}


\begin{document}\large
%\maketitle

\includepdf[pages={1}]{thesis-frontpage.pdf}

\begin{abstract}
 Streaming NESL (SNESL) is an experimental, first-order functional, nested data-parallel language, employing a streaming execution model and integrating with a cost model that can predict both time and space complexity.
 Practical experiments have demonstrated good performance of SNESL's implementation and provided empirical evidence of the validity of the cost model.
 
 In this thesis, we first extend SNESL to support recursive functions while preserving the cost model.
 This requires non-trivial extensions to SNESL's target language, SVCODE, and the flow graph of its streaming dataflow model to be dynamically completed at runtime.
 Two execution models of the extended SVCODE, the NESL-like eager one, and the streaming one, are given.
 
 Then we show the formalization of the semantics of a subset of the source and target languages, followed by the proof of the translation correctness and work cost preservation.
 
%TODO cost preservation ??
\end{abstract}


\tableofcontents



\input{intro.tex}
\input{imple.tex}
\input{snesl0-proof.tex}
\input{concl.tex}


\bibliography{thesis}
\bibliographystyle{alpha}



\end{document}
